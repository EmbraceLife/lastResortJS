<!DOCTYPE html>
<html>
  <head>
    <title>Let's write up myMap by building it up case by case</title>
  </head>
  <body>
    <!-- <script src="../tinytest.js"></script> -->
    <script src="../smallTest/smallTest.js"></script>
    <script>

    function map(array, callback, thisArg){
      var newArray = []; 

      if (thisArg) {
        callback = callback.bind(thisArg);
      } else {
        callback = callback.bind(undefined); 
      }

      var originalLength = array.length;

      for (i = 0; i < originalLength; i++) {
        if (array.hasOwnProperty(i)) {
          var result = callback(array[i], i, array);
          newArray.push(result); 
        }
      }
      
      return newArray; 
    }


    tests({
      "feature 1 done ::: 3Args ::: currentValue for current element which invokes callback; the index of the current element; and the array ": function() {
        console.groupCollapsed("Feature 1 logs");
        var arrayTest = [8];
        map(arrayTest, function(el,idx,arr){
          
          console.log("the current element should be 8 and is actually : ", el);
          eq(8, el);

          console.log("the current index should be 0, and is actually : ", idx);
          eq(0, idx);

          console.log("the array should be [8], and is actually : ", arr);
        });

        console.groupEnd();
      }, 


      "feature 2 done ::: returnNewArrayWithCallbackResult ::: map method  should return a new array": function(){
        console.groupCollapsed("Feature 2 logs");

        var arrayTest = [8];
        var newArray = map(arrayTest, function(el){
          
          return el - 8; 
        });

        console.log("the newArray should be [0] and is actually : ", newArray);
        eq(0, newArray[0]);

        console.groupEnd();
      }, 

      
      "Feature 3 done ::: thisArg ::: optional arg, either refers to an user given object or undefined": function(){
        console.groupCollapsed("Feature 3 logs");

        var arrayTest = [8];
        
        var newArray = map(arrayTest, function(el){
          console.log("this inside callback should be undefined (in Chrome it is window object), and actually is : ", this);
          eq(window, this);
        }); 
        
        var newArrayThis = map(arrayTest, function(el){
          console.log("this inside callback should be the object {number: -8}, and actually is : ", this);
          eq(-8, this.number);
        }, {"number": -8}); 
        
        console.groupEnd();
      },


      "Feature 4 done ::: numIterationsFixed ::: the range of the elements are fixed (the length of the array is recorded before the first call to callback)": function() {
        console.groupCollapsed("Feature 4 logs");

        var arrayTest = [1,2]; 
        var numCallbackRuns = 0;
        var arrayResult = map(arrayTest, function(el, idx, arr){
          arr.push("new");
          numCallbackRuns++;
        });
        console.log("the array should be [1,2,'new', 'new'] and actually is : ", arrayTest);
        eq(4, arrayTest.length);
        console.log("the total number of iterations should be 2 and is actually : ", numCallbackRuns);
        eq(2, numCallbackRuns);

        console.groupEnd();
      },

      "Feature 5 done ::: AppendedElementNotInvokeCallback ::: the appended elements won't get to invoke callback": function() {
        console.groupCollapsed("Feature 5 logs");

        var arrayTest = [1,2];
        var newArray = map(arrayTest, function(el, idx, arr){
        
          arr.push(3);  
          console.log("the array at the end of each iteraiton is : ", arr);
          return el + 0; 
        });

        console.log("the length of newArray is 2 and is actually : ", newArray.length);

        console.log("the first element of newArray should be 1 and is actually : ", newArray[0]);
        eq(1, newArray[0]);

        console.log("the second element of newArray should be 2 and is actually : ", newArray[1]);
        eq(2, newArray[1]);

        console.groupEnd();
      },
    
      "Feature 6 done ::: existingChangedItemInvokeCallback ::: the existing and changed item will invoke callback ": function(){
        console.groupCollapsed("Feature 6 logs");

        var arrayTest = [1,2];
        var newArray = map(arrayTest, function(el, idx, arr){
          if (idx === 0) {
            console.log("before array mutation, the array should be [1,2] and actually is : ", arr);

            arr[0] = 10;
            arr[1] = 9;
            
            console.log("after changing the existing items' values, the array should be [10,9] and actuall is : ", arr);
            
            console.log("at iteration ", idx, ", the current element should be 1 and is actually : ", el);
            eq(1, el);

          } else {
            console.log("at iteration ", idx, ", the current element should be 9 and is actually : ", el);
            eq(9, el);
          } 
        });

        console.groupEnd();
      }, 
    
      "Feature 7 done ::: existingElementDeletedNotInvoke ::: an element deleted after passing to map but before passing to callback, will not invoke callback": function() {
        console.groupCollapsed("Feature 7 logs");

        var arrayTest = [1,2];
        var numCallbackRuns = 0;
        var newArray = map(arrayTest, function(el, idx, arr){
          
          if (idx === 0) {
            console.log("Before splice the second item, arr should be [1,2] and actually is : ", arr);

            arr.splice(1, 1); 
          }

          numCallbackRuns++; 
          return el;
        });
        console.log("the numCallbackRuns should be 1 and is actually : ", numCallbackRuns);
        eq(1, numCallbackRuns);

        console.log("the newArray should [1], and is actually : ", newArray);

        console.groupEnd();
      },
    })
    
    </script>
  </body>
</html>