<!DOCTYPE html>
<html>
  <head>
    <title>Rewrite copyWithin</title>
  </head>
  <body>
    <script src="../../simpleTest.js"></script>
    <script>
      /* Now, let's write up the copyWithin function one test by another */
    function copyWithin(array, target, start, end){
      /* what if target < 0, the converted target will be length + target; otherwise, just target */
      function handleNeg(arg){
        if (arg < 0 && arg > -array.length){
          return array.length + arg;
        } /* else if (arg <= -array.length) {
          return 0; 
        } */
        return arg;
      }
      target = handleNeg(target);
      // if (target < 0) {
      //   target = array.length + target;
      // } 
      
      if (target >= array.length || target <= -array.length) {/* feature 14 */
        return array;
      }

      if (start >= array.length || start <= -array.length) {
        return array;
      }
      // if (start < 0) {/* handle negative start */
      //   start = array.length + start;
      // }
      start = handleNeg(start);

      start = (start) ? start : 0/* when start is omitted, it is default to 0 */
      
      /* we need to handle negative end  */
      // if (end < 0) {/* handle negative start */
      //   end = array.length + end;
      // }
      end = handleNeg(end);

      if (end >= array.length) {
        end = array.length;
      } else if (end <= -array.length){
        return array;
      }

      end = (end) ? end : array.length/* when end is omitted, make it full length */
      var copiedArray = [];/* create the copiedArray */
      for (i = start; i < end; i++) {/* feature 10 */
        // copiedArray[i] = array[i]; /* if i start 1, i = 0 will assumed to be empty */
        copiedArray.push(array[i]); 
      }

      if (target > start) {/* make the copied array trimmed  */
        copiedArray.splice(start-target, target-start);
      }/* make sure to use a simple array first */

      /* we need paste the copiedArray element to arrayTest starting from target */
      for (i = 0; i < copiedArray.length; i++){
        // if (copiedArray.hasOwnProperty(i)){

        array[target + i] = copiedArray[i];
        if (copiedArray[i] === undefined) {/* fearture 15 */
          delete array[target + i];
        }
        // }
      }/* now let's see whether the previous tests succeed or not */

      // array[target] = array[start];/* this only work on two elements or one element array for now for copying one element onto another. */
      return array;
    }

    /* 
    First of all, we do some some obvious refactor on the copyWithin function

    Now I would like to clean up feature descriptions and try some extreme cases on each feature. */
    tests({

      "Feature 1 (clean) ::: fixedLength ::: arrayTest should have the equal length with modified array ::: arrayTest.length === modified.length": function(){
        var arrayTest = [1,2,3,4];
        var modified = copyWithin(arrayTest, 0, 1, 2);
        console.groupCollapsed('Feature 1 logs');
        console.log("The length of arrayTest is : ", arrayTest.length, "the length of modified is : ", modified.length, "They should be equal.");
        eq(arrayTest.length, modified.length);
        console.groupEnd();
      }, 

      "Feature 2 (clean) ::: arrayMutable ::: arrayTest is mutable by copyWithin ::: arrayTestBeforeCopywithin[target] !== arrayTestAfterCopywithin[target]": function() {
        var arrayTest = [1,2];/* make it simpler */
        var target = 0;
        var start = 1;
        var originalTarget = arrayTest[target];
        var modified = copyWithin(arrayTest, target, start);
        console.groupCollapsed('Feature 2 logs');
        
        console.log("The original target before running copyWithin is : ", originalTarget, ", after is : ", modified[target], ". we expect that they aren't equal");
        eq(false, originalTarget === modified[target]);

        console.groupEnd();
      },


      "Feature 3 (clean) ::: targetReplacedByStart ::: original arrayTest[target] is replaced by original arrayTest[start] ::: newArray[start] === arrayTest[target]": function(){
        var arrayTest = [1,2,3,4];/* to make it more complex, use [1,2,3,4], instead of [1,2] The result should be the same without change*/
        var target = 0;
        var start = 1;/* an edge case that start > array.length, here my function can't handle */
        var originalStart = arrayTest[start];
        var modified = copyWithin(arrayTest, target, start);

        console.groupCollapsed('Feature 3 logs');
        console.log("modified[target]: ", modified[target], " should be equal to the original arrayTest[start]: ", originalStart, " and actually it is : ", modified[target] === originalStart);
        eq(modified[target], originalStart);
        
        console.groupEnd();
      },

      "Assistance 1 ::: arrayTest[negativeValue] is undefined": function(){
        var arrayTest = [1,2,3,4];
        var output = arrayTest[-1];
        console.groupCollapsed('Additional 1 logs');
        console.log("arrayTest[-1] should return undefined, and is actually : ", output);
        eq(undefined, output);
        console.groupEnd();
      },

      "Feature 4 (clean) ::: negativeTarget>LengthNeg::: If negative, target will be counted from the end ::: targetCvt = length + targetNeg ": function(){
        var arrayTest1 = [1,2,3,4];
        var arrayTest2 = [1,2,3,4];
        var start = 0;
        var negativeTarget = -1;/* experiment different values -1, -2, -3 */ 
        var convertedTarget = arrayTest1.length + negativeTarget;
        var modifiedNeg = copyWithin(arrayTest1, negativeTarget, start);
        var modifiedCvt = copyWithin(arrayTest2, convertedTarget, start);
        console.groupCollapsed('Feature 4 logs');
        
        console.log("the modifiedNeg is : ", modifiedNeg,);
        console.log("the modifiedCvt is : ", modifiedCvt);
        console.log("They are expected to have the same elements");
        console.groupEnd();
      },

      "Feature 4 (clean) ::: targetBeyondLengthNeg ::: if so, do nothing":function(){
        var arrayTest1 = [1,2,3,4];
        var arrayTest2 = [1,2,3,4];
        var start = 0;
        var negativeTarget = -8;/* experiment different values -1, -2, -3, -4, -5 (error)  */ 
        var convertedTarget = (-negativeTarget >= arrayTest1.length)? 0 : arrayTest1.length + negativeTarget;
        // var modifiedNeg = arrayTest1.copyWithin(negativeTarget, start);/* if |negTarget| >= 4, then do nothing */
        // var modifiedCvt = arrayTest2.copyWithin(convertedTarget, start);
        var modifiedNeg = copyWithin(arrayTest1, negativeTarget, start);/* if |negTarget| >= 4, then do nothing */
        var modifiedCvt = copyWithin(arrayTest2, convertedTarget, start);
        console.groupCollapsed('Feature 4 (Extreme) logs');
        
        console.log("the modifiedNeg is : ", modifiedNeg,);
        console.log("the modifiedCvt is : ", modifiedCvt);
        console.log("They are expected to have the same elements");
        console.groupEnd();
      },

      "Feature added (clean) ::: sameReference ::: the return array is the same reference array but mutated": function(){
        var arrayTest = [1,2,3,4];/* make it simple [1,2] or complex [1,2,3,4] */
        var target = 0; /* at or greater than the length 4 */
        var start = 2; /* experiment with 1,2,3 */
        // var original = arrayTest;/* this line is not necessary now */
        var modified = copyWithin(arrayTest, target, start);
        console.groupCollapsed('Additional 2 logs');
        console.log("arrayTest and modified array share the same reference: ", arrayTest === modified);
        eq(arrayTest, modified);
        console.groupEnd();
      },

      "Feature 5 (clean) ::: targetBeyondLengthPos ::: If target is at or greater than arr.length, nothing will be copied, just return array": function(){
        var arrayTest = [1,2,3,4];
        var target = 6; /* experiment with 4,5,6 */
        var modified = copyWithin(arrayTest, target);
        console.groupCollapsed('Feature 5 logs');
        console.log("nothing shall be copied to mutatedArray, and so it stays the same : ", modified);
        eq(arrayTest, modified);
        console.groupEnd();
      },

      "Feature 5 (clean) ::: startBeyondLength(Pos/Neg) ::: start >= length || start <= -length ===> do nothing":function(){
        var arrayTest = [1,2,3,4];
        var target = 0; 
        var start = 7; /* experiment with 4,5,6 or -4,-5,-6 all do nothing*/
        // var modified = arrayTest.copyWithin(target, start);
        var modified = copyWithin(arrayTest, target, start);
        console.groupCollapsed('Feature 5 extend to start logs');
        console.log("nothing shall be copied to mutatedArray, and so it stays the same : ", modified);
        eq(arrayTest, modified);
        console.groupEnd();
      },

      "Feature 5 (clean) ::: endBeyongLengthPos ::: end >= length ===> end can't exceed length":function(){
        var arrayTest = [1,2,3,4];
        var target = 0; 
        var start = 1; 
        var end = 4; /* experiment with 4,5,6 ===> end can't exceed length;*/
        // var modified = arrayTest.copyWithin(target, start, end);
        var modified = copyWithin(arrayTest, target, start, end);
        console.groupCollapsed('Feature 5 extend to end logs');
        console.log("nothing shall be copied to mutatedArray, and so it stays the same : ", modified);
        eq(arrayTest, modified);
        console.groupEnd();
      },

      "Feature 5 (clean) ::: endBeyondNegLength ::: end <= -length ===> do nothing":function(){
        var arrayTest = [1,2,3,4];
        var target = 0; 
        var start = 1; 
        var end = -8; /* or experiment with -4,-5,-6, do nothing*/
        // var modified = arrayTest.copyWithin(target, start, end);
        var modified = copyWithin(arrayTest, target, start, end);
        console.groupCollapsed('Feature 5 extend to end logs');
        console.log("nothing shall be copied to mutatedArray, and so it stays the same : ", modified);
        eq(arrayTest, modified);
        console.groupEnd();
      },

      "Assistance 2 ::: splice(-2, 2) to remove the last two element": function(){
        var arrayTest = [1,2,3,4];
        arrayTest.splice(-3,2)
        console.groupCollapsed('Additional 3 logs');
        console.log("arrayTest.splice(-3,2) should return [1,4], and actually returns ", arrayTest)
        eq(4, arrayTest[1]);
        console.groupEnd();
        
      },

      "Feature 6 (clean) ::: Target>StartCopiedTrim ::: If target is positioned after start, the copied sequence will be trimmed to fit arr.length ::: copiedPart.splice(start-target, target-start)": function(){
        var arrayTest = [1,2,3,4];/* make array larger, [1,2,3,4] */
        var target = 2;/* experiment 1,2,3 */
        var start = 1;/* experiment 0,1,2 */
        var modifedArray = copyWithin(arrayTest, target, start);
        console.groupCollapsed('Feature 6 logs');
        console.log("the modified array should be [1,2,2,3], and is actually : ", modifedArray);
        eq(2, modifedArray[1]);
        console.groupEnd();
      },

      "Feature 7 (clean)::: copyFromStart ::: Zero-based index at which to start copying elements from ::: originalStart === modifiedArray[target] ": function(){
        var arrayTest = [1,2,3,4];
        var target = 0;
        var start = 3;/* experiment 0,1,2,3 */
        var originalStart = arrayTest[start];
        var modifiedArray = copyWithin(arrayTest, target, start);
        console.groupCollapsed('Feature 7 logs');
        console.log("arrayTestOriginal[start] === modifiedArray[target], true or false? : ", originalStart === modifiedArray[target]);
        eq(originalStart, modifiedArray[target]);
        console.groupEnd();
      },

      "Feature 8 (clean) ::: negStart>LengthNeg ::: If negative, start will be counted from the end ::: negStart ==> startCvt = length + negStart": function(){
        var arrayTest1 = [1,2,3,4];
        var arrayTest2 = [1,2,3,4];
        var negStart = -3;/* experiment -1, -2, -3 */
        var startCvt = arrayTest1.length + negStart;
        var modified1 = copyWithin(arrayTest1, 0, negStart);
        var modified2 = copyWithin(arrayTest2, 0, startCvt);
        console.groupCollapsed('Feature 8 logs');
        console.log("modified1[0] and modified2[0] should be equal ", modified1[0] === modified2[0]);
        eq(modified1[0], modified2[0]);
        console.groupEnd();
      },

      "Feature 9 (clean) ::: startOmitted ::: If start is omitted, copyWithin will copy from index 0 ::: arrayTest.copyWithin(target, 0) should be equivalent to arrayTest.copyWithin(target); ": function(){
        var arrayTest1 = [1,2,3,4];
        var arrayTest2 = [1,2,3,4];
        var target = -20; /* can be any number */
        var start = 0;
        var modified1 = copyWithin(arrayTest1, target, start);
        var modified2 = copyWithin(arrayTest2, target);
        console.groupCollapsed('Feature 9 logs');
        console.log("modified1 : ", modified1, " and modified2 :", modified2, " should be equal ");
        eq(modified1[0], modified2[0]);
        console.groupEnd();
      },
      

      "Feature 10 (clean)::: stopCopyBeforeEnd<=Length ::: Zero-based index at which to end copying elements from": function(){
        var arrayTest = [1,2,3,4];
        var target = 0;
        var start = 2;
        var end = 4;/* copied elements at index 2, index 3 */
        var modified = copyWithin(arrayTest, target, start, end);
        console.groupCollapsed('Feature 10 logs');
        console.log("modified array's first element should be 3, and is actually : ", modified[0]);
        eq(3, modified[0]);
        console.log("modified array's second element should be 4, and is actually : ", modified[1]);
        eq(4, modified[1]);
        console.groupEnd();
        /* I just forgot to record the experimental part: what I did is to change values for start and end. I tried 1, 2 for start, tried 3, 4 for end. The finished version used start = 2, end = 4, and tested on modified[0], modified[1] */
      },

      "Feature 11 (clean)::: negEnd ::: If negative, end will be counted from the end. ::: arrayTest.copyWithin(0, 0, -1) should be equal to arrayTest.copyWithin(0, 0, arrayTest.length-1) ": function(){

        var arrayTest1 = [1,2,3,4];
        var arrayTest2 = [1,2,3,4];
        var target = 0;
        var start = 20;/* 1,2,3,20 */
        var negEnd = -1;
        var modified1 = copyWithin(arrayTest1, target, start, negEnd);
        var modified2 = arrayTest2.copyWithin(target, start, negEnd);
        console.groupCollapsed('Feature 11 logs');
        console.log("modified1 : ", modified1, " and modified2 : ", modified2, " should be equal ");
        console.groupEnd();
      },

      "Feature 12 (clean)::: endOmit ::: If end is omitted, copyWithin will copy until the last index (default to arr.length)": function(){
        var arrayTest1 = [1,2,3,4];
        var arrayTest2 = [1,2,3,4];
        var target = 1;
        var start = 0;
        // var endOmit = arrayTest1.length;
        var modified1 = copyWithin(arrayTest1, target, start);
        // var modified2 = copyWithin(arrayTest2, target, start, endOmit);
        var modified2 = arrayTest2.copyWithin(target, start);
        console.groupCollapsed('Feature 12 logs');
        console.log("modified1 : ", modified1, " and modified2 :", modified2, " should be equal ");
        console.groupEnd();
      },
      /* tests on end are finished */

      "Feature 13 (clean) ::: overlap ::: pasted sequence will have the copied values even when the copy and paste region overlap ::: target = 0; start = 1; end = 3; the copied sequence [idx1, idx2], the pasted equence [idx0, idx1], they overlap at idx1. the original idx1 will be replaced by original idx2, and current idx2 is still the same to original idx2.": function(){
        var arrayTest = [1,2,3,4];
        var target = 0;
        var start = 1;
        var end = 3;
        var modified = copyWithin(arrayTest, target, start, end);
        /* based on our analysis above, inside modified array, the idx1 should be 3, and idx2 should be 3 too */
        console.groupCollapsed('Feature 13 logs');
        console.log("modified[1] should be 3, and is actually ", modified[1], "modified[2] should be 3, and is actually : ", modified[2]);
        eq(3, modified[1]);
        eq(3, modified[2]);
        console.groupEnd();
      },

      "Feature 14 (clean) ::: emptyArray ::: it returns empty array": function(){
        var arrayTest = [];
        // var modified = arrayTest.copyWithin(20);
        var modified = copyWithin(arrayTest, 20);/* why it already works? */
        console.groupCollapsed('Feature 14 logs');
        console.log("empty array run copyWithin should return empty array, and actually returns : ", modified);
        console.groupEnd();
      },

      "Feature 15 (clean)::: sparseArray ::: leave missing alone": function(){
        console.groupCollapsed('Feature 15 logs');
        var arrayTest = [1,,,4];
        console.log("original array: ", arrayTest);
        // var modified = arrayTest.copyWithin(0, 1);
        var modified = copyWithin(arrayTest, 0, 1);
        console.log("the modified array should be [,,4,4], and is actually, ", modified);
        console.groupEnd();
      },


      "Tests Done ::: The copyWithin function is intentionally generic, it does not require that its this value be an Array object (I don't think we can write a feature/test on this, as we can't access this from outside like what we did with callback in forEach) ::: The copyWithin method is a mutable method. It does not alter the length of this, but it will change its content and create new properties, if necessary (the array is mutable, we have tested before explicitly on Feature 2). I have also quickly checked on the Polyfill to make sure it does not used any other array methods to implement copyWithin.": function(){

      },
      })
    
    </script>
  </body>
</html>